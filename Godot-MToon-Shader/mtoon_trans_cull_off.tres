[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode specular_disabled,ambient_light_disabled;

// VARIANTS:
// DEFAULT_MODE:
const float isOutline = 0.0;

// OUTLINE:
// // Comment `const float isOutline = 0.0;`
// render_mode cull_front;
// const float isOutline = 1.0;
// // Uncomment `ALPHA = alpha;` and comment `if (alpha < _Cutoff) { discard; }` at end of fragment()

// TRANSPARENT:
// // Uncomment `ALPHA = alpha;` and comment `if (alpha < _Cutoff) { discard; }` at end of fragment()

// TRANSPARENT_WITH_ZWRITE:
//render_mode depth_draw_always;
// // Uncomment `ALPHA = alpha;` and comment `if (alpha < _Cutoff) { discard; }` at end of fragment()

// CULL_OFF:
// render_mode cull_disabled;

// TRANSPARENT_CULL_OFF:
render_mode cull_disabled;
// // Uncomment `ALPHA = alpha;` and comment `if (alpha < _Cutoff) { discard; }` at end of fragment()

// TRANSPARENT_WITH_ZWRITE_CULL_OFF:
// render_mode cull_disabled,depth_draw_always;
// // Uncomment `ALPHA = alpha;` and comment `if (alpha < _Cutoff) { discard; }` at end of fragment()


const bool CALCULATE_LIGHTING_IN_FRAGMENT = true;


const float tmpx=0.0; float LM_SCENEDATA_FLOAT (float tmp) {return tmpx;}const vec2 tmp2x=vec2(0.0); vec2 LM_SCENEDATA_VEC2 (vec2 tmp2) {return tmp2x;}const int tmpix=0; int LM_GL_INT (int tmpi) {return tmpix;}
const vec3 tmp3x=vec3(0.0); vec3 LM_SCENEDATA_VEC3 (vec3 tmp3) {return tmp3x;}const vec4 tmp4x=vec4(0.0); vec4 LM_SCENEDATA_VEC4 (vec4 tmp4) {return tmp4x;}
const bool tmpbx=false; bool LM_SCENEDATA_BOOL (bool tmpb) {return tmpbx;}const mat4 tmpm4x=mat4(0.0); mat4 LM_SCENEDATA_MAT4 (mat4 tmpm4) {return tmpm4x;}

const vec4 tmpverty=vec4(0.0); const vec4 tmpvertyUSE_VERTEX_LIGHTING=vec4(0.0); vec4 LM_VERTLIGHT (vec4 tmpvert) {return tmpverty+tmpvertyUSE_VERTEX_LIGHTING;}const vec4 tmpflvy=vec4(0.0); const vec4 tmpflvyUSE_FORWARD_LIGHTING=vec4(0.0);
vec4 LM_FWDLIGHT (vec4 tmpflv, int idx) {return tmpflvy+tmpflvyUSE_FORWARD_LIGHTING;}
const mat4 tmpflmy=mat4(0.0); const mat4 tmpflmyUSE_FORWARD_LIGHTING=mat4(0.0); mat4 LM_FWDLIGHT_MAT4 (mat4 tmpflm, int idx) {return tmpflmy+tmpflmyUSE_FORWARD_LIGHTING;}
const int tmpfliy=0; const int tmpfliyUSE_FORWARD_LIGHTING=0; int LM_FWDLIGHT_INT (int tmpfli) {return tmpfliy+tmpfliyUSE_FORWARD_LIGHTING;}
const vec4 tmpdlvd=vec4(0.0); const vec4 tmpdlvdUSE_LIGHT_DIRECTIONAL=vec4(0.0); vec4 LM_DIRLIGHT (vec4 tmpdlv) {return tmpdlvd+tmpdlvdUSE_LIGHT_DIRECTIONAL;}const mat4 tmpdlmd=mat4(0.0); const mat4 tmpdlmdUSE_LIGHT_DIRECTIONAL=mat4(0.0);
mat4 LM_DIRLIGHT_MAT4 (mat4 tmpdlm) {return tmpdlmd+tmpdlmdUSE_LIGHT_DIRECTIONAL;}const bool tmpdlbd=false; const bool tmpdlbdUSE_LIGHT_DIRECTIONAL=false; bool LM_DIRLIGHT_BOOL (bool tmpdlb) {return tmpdlbd||tmpdlbdUSE_LIGHT_DIRECTIONAL;}
const int tmpgipliy=0; const int tmpgipliyUSE_GI_PROBES=0; int LM_GIPROBES (int tmpgipli) {return tmpgipliy+tmpgipliyUSE_GI_PROBES;}

const vec3 tmpatplios=vec3(0.0);
const vec3 tmpatpliosUSE_SHADOW=vec3(0.0);
const vec3 tmpatpliosLIGHT_DIRECTIONAL_SHADOW=vec3(0.0);
const vec3 tmpatpliosUSE_SHADOWLIGHT_DIRECTIONAL_SHADOW=vec3(0.0);
const vec3 tmpatpliosUSE_CONTACT_SHADOWS=vec3(0.0);
const vec3 tmpatpliosUSE_SHADOWUSE_CONTACT_SHADOWS=vec3(0.0);
const vec3 tmpatpliosLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS=vec3(0.0);
const vec3 tmpatpliosUSE_SHADOWLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS=vec3(0.0);
vec3 LM_SHADOWATTEN (vec3 tmpatpli) {return tmpatplios+tmpatpliosUSE_SHADOW+tmpatpliosLIGHT_DIRECTIONAL_SHADOW+tmpatpliosUSE_SHADOWLIGHT_DIRECTIONAL_SHADOW+tmpatpliosUSE_CONTACT_SHADOWS+
tmpatpliosUSE_SHADOWUSE_CONTACT_SHADOWS+tmpatpliosLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS+tmpatpliosUSE_SHADOWLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS;}

const float tmpatplids=(0.0);
const float tmpatplidsLIGHT_DIRECTIONAL_SHADOW=(0.0);
const float tmpatplidsLIGHT_USE_PSSM2=(0.0);
const float tmpatplidsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2=(0.0);
const float tmpatplidsLIGHT_USE_PSSM4=(0.0);
const float tmpatplidsLIGHT_USE_PSSM2LIGHT_USE_PSSM4=(0.0);
const float tmpatplidsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM4=(0.0);
const float tmpatplidsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2LIGHT_USE_PSSM4=(0.0);
float LM_DIRSHADOW (float tmpatpli) {return tmpatplids+tmpatplidsLIGHT_DIRECTIONAL_SHADOW+tmpatplidsLIGHT_USE_PSSM2+tmpatplidsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2+
tmpatplidsLIGHT_USE_PSSM4+tmpatplidsLIGHT_USE_PSSM2LIGHT_USE_PSSM4+tmpatplidsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM4+tmpatplidsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2LIGHT_USE_PSSM4;}

const float tmpatplisbl=(0.0);
const float tmpatplisblLIGHT_USE_PSSM_BLEND=(0.0);
const float tmpatplisblLIGHT_USE_PSSM2=(0.0);
const float tmpatplisblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2=(0.0);
const float tmpatplisblLIGHT_USE_PSSM4=(0.0);
const float tmpatplisblLIGHT_USE_PSSM2LIGHT_USE_PSSM4=(0.0);
const float tmpatplisblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM4=(0.0);
const float tmpatplisblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2LIGHT_USE_PSSM4=(0.0);
float LM_DIRSHADOWBLEND (float tmpatpli) {return tmpatplisbl+tmpatplisblLIGHT_USE_PSSM_BLEND+tmpatplisblLIGHT_USE_PSSM2+tmpatplisblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2+
tmpatplisblLIGHT_USE_PSSM4+tmpatplisblLIGHT_USE_PSSM2LIGHT_USE_PSSM4+tmpatplisblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM4+tmpatplisblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2LIGHT_USE_PSSM4;}

const bool tmpatplbbool=false;const bool tmpatplbboolUSE_LIGHTMAP_CAPTURE=false;const bool tmpatplbboolUSE_LIGHTMAP=false;const bool tmpatplbboolUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE=false;
bool LM_CHECKDEFINE (bool tmpatplb) {return tmpatplbbool||tmpatplbboolUSE_LIGHTMAP_CAPTURE||tmpatplbboolUSE_LIGHTMAP||tmpatplbboolUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE;}
const vec3 tmpatpliat=vec3(0.0);const vec3 tmpatpliatUSE_RADIANCE_MAP=vec3(0.0);const vec3 tmpatpliatUSE_LIGHTMAP_CAPTURE=vec3(0.0);const vec3 tmpatpliatUSE_RADIANCE_MAPUSE_LIGHTMAP_CAPTURE=vec3(0.0);
const vec3 tmpatpliatUSE_LIGHTMAP=vec3(0.0);const vec3 tmpatpliatUSE_RADIANCE_MAPUSE_LIGHTMAP=vec3(0.0);const vec3 tmpatpliatUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE=vec3(0.0);
const vec3 tmpatpliatUSE_RADIANCE_MAPUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE=vec3(0.0);
vec3 LM_AMBIENTTERM (vec3 tmpatpli) {return tmpatpliat+tmpatpliatUSE_RADIANCE_MAP+tmpatpliatUSE_LIGHTMAP_CAPTURE+tmpatpliatUSE_RADIANCE_MAPUSE_LIGHTMAP_CAPTURE+tmpatpliatUSE_LIGHTMAP
+tmpatpliatUSE_RADIANCE_MAPUSE_LIGHTMAP+tmpatpliatUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE+tmpatpliatUSE_RADIANCE_MAPUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE;}
const vec3 tmperlplierl=vec3(0.0); const vec3 tmperlplierlUSE_RADIANCE_MAP=vec3(0.0); vec3 LM_ENVREFLLIGHT (vec3 tmperlpli) {return tmperlplierl+tmperlplierlUSE_RADIANCE_MAP;}

const bool lm_macro_system_enabled_ = false;
const int env_reflection_light_ = 0;const vec3 ambient_term_ = vec3(0.0);const int refl_process_ = 0;const bool USE_LIGHTMAP = false;const bool USE_LIGHTMAP_CAPTURE = false;
const float dir_shadow_fade_ = 0.0;const float dir_shadow_blend_ = 0.0;const float dir_shadow_which_matrix_ = 0.0;const float dir_shadow_offset_ = 0.0;
const vec3 dir_shadow_atten_ = vec3(0.0);const vec3 spot_shadow_atten_ = vec3(0.0);const vec3 omni_shadow_atten_ = vec3(0.0);
const mat4 gi_probes_compute_ = mat4(0.0);const mat4 world_transform_ = mat4(0.0);const vec4 color_interp_ = vec4(0.0);const vec2 uv_interp_ = vec2(0.0);const vec2 uv2_interp_ = vec2(0.0);const vec3 tangent_interp_ = vec3(0.0);
const vec3 binormal_interp_ = vec3(0.0);const vec3 vertex_interp_ = vec3(0.0);const vec3 normal_interp_ = vec3(0.0);const mat4 radiance_inverse_xform_ = mat4(0.0);const float radiance_ambient_contribution_ = float(0.0);
const int gl_primitiveid_ = 0;const int gl_instanceid_ = 0;const int gl_vertexid_ = 0;
// SceneData
const mat4 projection_matrix_ = mat4(0.0);const mat4 inv_projection_matrix_ = mat4(0.0);const mat4 camera_inverse_matrix_ = mat4(0.0);const mat4 camera_matrix_ = mat4(0.0);const vec4 ambient_light_color_ = vec4(0.0);const vec4 bg_color_ = vec4(0.0);
const vec4 fog_color_enabled_ = vec4(0.0);const vec4 fog_sun_color_amount_ = vec4(0.0);const float ambient_energy_ = float(0.0);const float bg_energy_ = float(0.0);const float z_offset_ = float(0.0);const float z_slope_scale_ = float(0.0);
const float shadow_dual_paraboloid_render_zfar_ = float(0.0);const float shadow_dual_paraboloid_render_side_ = float(0.0);
const vec2 viewport_size_ = vec2(0.0);const vec2 screen_pixel_size_ = vec2(0.0);const vec2 shadow_atlas_pixel_size_ = vec2(0.0);const vec2 directional_shadow_pixel_size_ = vec2(0.0);const float time_ = float(0.0);const float z_far_ = float(0.0);
const float reflection_multiplier_ = float(0.0);const float subsurface_scatter_width_ = float(0.0);const float ambient_occlusion_affect_light_ = float(0.0);const float ambient_occlusion_affect_ao_channel_ = float(0.0);
const float opaque_prepass_threshold_ = float(0.0);const bool fog_depth_enabled_ = bool(0.0);const float fog_depth_begin_ = float(0.0);const float fog_depth_end_ = float(0.0);const float fog_density_ = float(0.0);
const float fog_depth_curve_ = float(0.0);const bool fog_transmit_enabled_ = bool(0.0);const float fog_transmit_curve_ = float(0.0);
const bool fog_height_enabled_ = bool(0.0);const float fog_height_min_ = float(0.0);const float fog_height_max_ = float(0.0);const float fog_height_curve_ = float(0.0);

// DirectionalLightData
const vec4 dir_light_pos_inv_radius_ = vec4(0.0);const vec4 dir_light_direction_attenuation_ = vec4(0.0);const vec4 dir_light_color_energy_ = vec4(0.0);const vec4 dir_light_params_ = vec4(0.0);const vec4 dir_light_clamp_ = vec4(0.0);
const vec4 dir_shadow_color_contact_ = vec4(0.0);const mat4 dir_shadow_matrix1_ = mat4(0.0);const mat4 dir_shadow_matrix2_ = mat4(0.0);const mat4 dir_shadow_matrix3_ = mat4(0.0);const mat4 dir_shadow_matrix4_ = mat4(0.0);
const vec4 dir_shadow_split_offsets_ = vec4(0.0);const bool has_dir_light_ = false;
//Vertex
const vec4 diffuse_light_interp_ = vec4(0.0);const vec4 specular_light_interp_ = vec4(0.0);
// struct LightData, by m_idx
const int omni_light_count_ = 0;const vec4 omni_light_pos_inv_radius_ = vec4(0.0);const vec4 omni_light_direction_attenuation_ = vec4(0.0);const vec4 omni_light_color_energy_ = vec4(0.0);const vec4 omni_light_params_ = vec4(0.0);
const vec4 omni_light_clamp_ = vec4(0.0);const vec4 omni_shadow_color_contact_ = vec4(0.0);const mat4 omni_shadow_matrix_ = mat4(0.0);
// struct LightData, by m_idx
const int spot_light_count_ = 0;const vec4 spot_light_pos_inv_radius_ = vec4(0.0);const vec4 spot_light_direction_attenuation_ = vec4(0.0);const vec4 spot_light_color_energy_ = vec4(0.0);const vec4 spot_light_params_ = vec4(0.0);
const vec4 spot_light_clamp_ = vec4(0.0);const vec4 spot_shadow_color_contact_ = vec4(0.0);const mat4 spot_shadow_matrix_ = mat4(0.0);
// struct ReflectionData, by m_idx
const int reflection_count_ = 0;const vec4 box_extents_ = vec4(0.0);const vec4 box_offset_ = vec4(0.0);const vec4 params_ = vec4(0.0);const vec4 ambient_ = vec4(0.0);const vec4 atlas_clamp_ = vec4(0.0);const mat4 local_matrix_ = mat4(0.0);



uniform vec4 albedo : hint_color = vec4(1.0,1.0,1.0,1.0);
uniform sampler2D texture_albedo : hint_albedo;
uniform vec3 uv1_scale = vec3(1.0,1.0,1.0);
uniform vec3 uv1_offset;
//uniform float specular;
//uniform float metallic;
//uniform float roughness : hint_range(0,1);
//uniform float point_size : hint_range(0,128);
uniform sampler2D texture_normal : hint_normal; // \"Normal Texture\"
uniform float normal_scale : hint_range(-16,16);


uniform float _EnableAlphaCutout : hint_range(0,1,1) = 0.0;
uniform float _Cutoff : hint_range(0,1) = 0.5;
//const vec4 _Color = albedo; // \"Lit Texture + Alpha\"
uniform vec4 _ShadeColor : hint_color = vec4(0.97, 0.81, 0.86, 1); // \"Shade Color\"
//const sampler2D _MainTex = texture_albedo;
//uniform vec4 _MainTex_ST;
uniform sampler2D _ShadeTexture : hint_albedo;
//uniform float _BumpScale = 1.0; // \"Normal Scale\"
//uniform sampler2D _BumpMap : hint_normal; // \"Normal Texture\"
uniform sampler2D _ReceiveShadowTexture : hint_white;
uniform float _ReceiveShadowRate = 1.0; // \"Receive Shadow\"
uniform sampler2D _ShadingGradeTexture : hint_white;
uniform float _ShadingGradeRate = 1.0; // \"Shading Grade\"
uniform float _ShadeShift : hint_range(-1.0, 1.0) = 0.0;
uniform float _ShadeToony : hint_range(0.0, 1.0) = 0.9;
uniform float _LightColorAttenuation : hint_range(0.0, 1.0) = 0.0;
uniform float _IndirectLightIntensity : hint_range(0.0, 1.0) = 0.1;
uniform sampler2D _RimTexture : hint_albedo;
uniform vec4 _RimColor : hint_color = vec4(0,0,0,1);
uniform float _RimLightingMix : hint_range(0.0, 1.0) = 0.0;
uniform float _RimFresnelPower : hint_range(0.0, 100.0) = 1.0;
uniform float _RimLift : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D _SphereAdd : hint_black_albedo; // \"Sphere Texture(Add)\"
uniform vec4 _EmissionColor : hint_color = vec4(0,0,0,1); // \"Color\"
uniform sampler2D _EmissionMap : hint_albedo;
// Not implemented:
// uniform float _OutlineWidthScreenCoordinates : hint_range(0,1,1);
uniform sampler2D _OutlineWidthTexture : hint_white;
uniform float _OutlineWidth : hint_range(0.01, 1.0) = 0.5;
uniform float _OutlineScaledMaxDistance : hint_range(1,10) = 1;
uniform float _OutlineMixedLighting : hint_range(0,1,1);
uniform vec4 _OutlineColor : hint_color = vec4(0,0,0,1);
uniform float _OutlineLightingMix : hint_range(0,1) = 0;
uniform sampler2D _UvAnimMaskTexture : hint_white;
uniform float _UvAnimScrollX = 0;
uniform float _UvAnimRotation = 0;
uniform float _UvAnimScrollY = 0;
uniform float _DebugMode : hint_range(0,3,1) = 0.0;

uniform float _MToonVersion = 33;

// const
const float PI_2 = 6.28318530718;
const float EPS_COL = 0.00001;


varying vec4 posWorld; // : TEXCOORD0;
varying vec3 tspace0; // : TEXCOORD1;
varying vec3 tspace1; // : TEXCOORD2;
varying vec3 tspace2; // : TEXCOORD3;


void vertex() {
	UV=UV*uv1_scale.xy+uv1_offset.xy;
	COLOR=COLOR;

	if (isOutline == 1.0) {
	    float outlineTex = textureLod(_OutlineWidthTexture, UV, 0).r;
	    vec3 worldNormalLength = vec3(1.0/length(mat3(transpose(WORLD_MATRIX)) * NORMAL));
	    vec3 outlineOffset = 0.01 * _OutlineWidth * outlineTex * worldNormalLength * NORMAL;
	    VERTEX += outlineOffset;
	}
	/*
#elif defined(MTOON_OUTLINE_WIDTH_SCREEN)
    vec4 nearUpperRight = (xINV_PROJECTION_MATRIX * vec4(1, 1, 0, 1));
    float aspect = abs(nearUpperRight.y / nearUpperRight.x);
    vec3 viewNormal = mat3(xINV_CAMERA_MATRIX) * mat3(xWORLD_MATRIX) * normal.xyz;
    vec3 clipNormal = TransformViewToProjection(viewNormal.xyz);
    vec2 projectedNormal = normalize(clipNormal.xy);
    projectedNormal *= min(vertex.w, _OutlineScaledMaxDistance);
    projectedNormal.x *= aspect;
    vertex.xy += 0.01 * _OutlineWidth * outlineTex * projectedNormal.xy * saturate(1 - abs(normalize(viewNormal).z)); // ignore offset when normal toward camera
#else
    float4 vertex = UnityObjectToClipPos(v.vertex);
#endif
	*/

	posWorld = (MODELVIEW_MATRIX*vec4(VERTEX.xyz, 1.0));
    vec3 worldNormal = mat3(MODELVIEW_MATRIX)*NORMAL;
    vec3 worldTangent = mat3(MODELVIEW_MATRIX)*TANGENT;
    vec3 worldBitangent = mat3(MODELVIEW_MATRIX)*BINORMAL;
    tspace0 = vec3(worldTangent.x, worldBitangent.x, worldNormal.x);
    tspace1 = vec3(worldTangent.y, worldBitangent.y, worldNormal.y);
    tspace2 = vec3(worldTangent.z, worldBitangent.z, worldNormal.z);
}

vec3 UnpackScaleNormal(vec4 normalmap, float scale) {
	normalmap.xy = scale * (normalmap.xy * 2.0 - 1.0);
	normalmap.z = sqrt(max(0.0, 1.0 - dot(normalmap.xy, normalmap.xy))); //always ignore Z, as it can be RG packed, Z may be pos/neg, etc.
	return normalmap.xyz;
}

vec3 calculateLighting(vec2 mainUv, float dotNL, float lightAttenuation, vec4 shade, vec4 lit, vec3 lightColor, out vec3 col, out float lightIntensity) {
    // Decide albedo color rate from Direct Light
    float shadingGrade = 1.0 - _ShadingGradeRate * (1.0 - texture(_ShadingGradeTexture, mainUv).r);
    lightIntensity = dotNL; // [-1, +1]
    lightIntensity = lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]
    lightIntensity = lightIntensity * lightAttenuation; // receive shadow
    lightIntensity = lightIntensity * shadingGrade; // darker
    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]
    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
    float maxIntensityThreshold = mix(1, _ShadeShift, _ShadeToony);
    float minIntensityThreshold = _ShadeShift;
    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)),0.0,1.0);

    col = mix(shade.rgb, lit.rgb, lightIntensity);
    //DEBUG_OVERRIDE = vec4(vec3(shade.rgb),1.0);
    //DEBUG_OVERRIDE = vec4(vec3(col.rgb),1.0);
    // Direct Light
    vec3 lighting = lightColor / 3.14159;
    lighting = mix(lighting, max(vec3(EPS_COL), max(lighting.x, max(lighting.y, lighting.z))), _LightColorAttenuation); // color atten
	return lighting;
}

vec3 calculateAddLighting(vec2 mainUv, float dotNL, float dotNV, float shadowAttenuation, vec3 lighting, vec3 col) {
//    UNITY_LIGHT_ATTENUATION(shadowAttenuation, i, posWorld.xyz);
//#ifdef _ALPHABLEND_ON
//    lighting *= step(0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
//#endif
    lighting *= 0.5; // darken if additional light.
    lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using float lambert
    lighting *= shadowAttenuation; // darken if receiving shadow
    col *= lighting;

    // parametric rim lighting
    vec3 staticRimLighting = vec3(0.0);
    vec3 mixedRimLighting = lighting;

    vec3 rimLighting = mix(staticRimLighting, mixedRimLighting, _RimLightingMix);
    vec3 rim = pow(clamp(1.0 - dotNV + _RimLift, 0.0, 1.0), _RimFresnelPower) * _RimColor.rgb * texture(_RimTexture, mainUv).rgb;
    col += mix(rim * rimLighting, vec3(0.0), isOutline);
	return col;
}

void fragment() {
	bool _NORMALMAP = true; //textureSize(texture_normal, 0).x > 8;
	bool MTOON_OUTLINE_COLOR_FIXED = _OutlineMixedLighting == 0.0;
	bool MTOON_OUTLINE_COLOR_MIXED = _OutlineMixedLighting == 1.0;

    // uv
    vec2 mainUv = UV; //TRANSFORM_TEX(i.uv0, _MainTex);
    
    // uv anim
    float uvAnim = texture(_UvAnimMaskTexture, mainUv).r * TIME;
    // translate uv in bottom-left origin coordinates.
    mainUv += vec2(_UvAnimScrollX, -_UvAnimScrollY) * uvAnim;
    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.
    float rotateRad = _UvAnimRotation * PI_2 * uvAnim;
    const vec2 rotatePivot = vec2(0.5, 0.5);
    mainUv = mat2(vec2(cos(rotateRad), -sin(rotateRad)), vec2(-sin(rotateRad), cos(rotateRad))) * (mainUv - rotatePivot) + rotatePivot;
    
    // main tex
    vec4 mainTex = texture(texture_albedo, mainUv);
    vec4 DEBUG_OVERRIDE = vec4(0.0);
    // alpha
	float alpha = albedo.a * mainTex.a;
 
    // normal
    vec3 viewNormal;
	if (_NORMALMAP) {
	    vec3 tangentNormal = UnpackScaleNormal(texture(texture_normal, mainUv), normal_scale);
	    viewNormal.x = dot(tspace0, tangentNormal);
	    viewNormal.y = dot(tspace1, tangentNormal);
	    viewNormal.z = dot(tspace2, tangentNormal);
	} else {
	    viewNormal = vec3(tspace0.z, tspace1.z, tspace2.z);
	}
    vec3 viewView = -VIEW;
    viewNormal *= step(0.0, dot(viewView, viewNormal)) * 2.0 - 1.0; // flip if projection matrix is flipped
    viewNormal *= mix(+1.0, -1.0, isOutline);
    viewNormal = normalize(viewNormal);

    // Unity lighting

    //vec3 lightDir = mix(LM_DIRLIGHT(dir_light_direction_attenuation_).xyz, normalize(_WorldSpaceLightPos0.xyz - i.posWorld.xyz), _WorldSpaceLightPos0.w);
	vec3 lightDir = LM_DIRLIGHT(dir_light_direction_attenuation_).xyz;
	// TODO: LM_DIRLIGHT(dir_light_color_energy_).w
    vec3 lightColor = (LM_DIRLIGHT(dir_light_color_energy_).rgb) * 1.0 * step(0.5, length(lightDir)); // length(lightDir) is zero if directional light is disabled.
	//DEBUG_OVERRIDE = vec4(LM_DIRLIGHT(dir_light_color_energy_).rgb * (1.0 / 3.1415926), 1.0);
    float dotNL = dot(lightDir, viewNormal);
	float lightAttenuation = 1.0;
//#ifndef MTOON_FORWARD_ADD
    //UNITY_LIGHT_ATTENUATION(shadowAttenuation, i, posWorld.xyz);
	float dir_shadow_offset = LM_DIRSHADOW(dir_shadow_offset_);
	float dir_shadow_blend = LM_DIRSHADOWBLEND(dir_shadow_blend_);
	float dir_shadow_fade = LM_DIRSHADOWBLEND(dir_shadow_fade_);
	float dir_shadow_which_matrix = LM_DIRSHADOW(dir_shadow_which_matrix_);
	float shadowAttenuation = length(LM_SHADOWATTEN(dir_shadow_atten_))/length(vec3(1.0,1.0,1.0));//vec3->float???
	
    lightAttenuation = shadowAttenuation * mix(1, shadowAttenuation, _ReceiveShadowRate * texture(_ReceiveShadowTexture, mainUv).r);

	// Indirect Light
    vec4 reflection_accum = vec4(1.0, 0.0, 0.0, 0.0);
    vec4 ambient_accum = vec4(0.0, 0.0, 0.0, 0.0);
	vec3 env_reflection_light = vec3(0.0);
	vec3 oldNormal = NORMAL;
	vec3 oldTangent = TANGENT;
	vec3 oldBinormal = BINORMAL;
	
	NORMAL = mat3(CAMERA_MATRIX) * vec3(0.0,1.0,0.0);
	TANGENT = mat3(CAMERA_MATRIX) * vec3(1.0,0.0,0.0);
	BINORMAL = mat3(CAMERA_MATRIX) * vec3(0.0,0.0,1.0);
	vec3 ambient_light = LM_AMBIENTTERM(ambient_term_);
    for (int idx = 0; idx < LM_FWDLIGHT_INT(reflection_count_); idx++) {
		LM_FWDLIGHT_INT(refl_process_);
    }
	NORMAL *= -1.0;
	TANGENT *= -1.0;
	ambient_light += LM_AMBIENTTERM(ambient_term_);
    for (int idx = 0; idx < LM_FWDLIGHT_INT(reflection_count_); idx++) {
		LM_FWDLIGHT_INT(refl_process_);
    }
	if (!LM_CHECKDEFINE(USE_LIGHTMAP) && !LM_CHECKDEFINE(USE_LIGHTMAP_CAPTURE)) {
	    if (ambient_accum.a > 0.0) {
			ambient_light = ambient_accum.rgb / ambient_accum.a;
	    }
	}
	vec3 toonedGI = ambient_light * 0.5 + LM_VERTLIGHT(diffuse_light_interp_).rgb;
	NORMAL = oldNormal;
	TANGENT = oldTangent;
	BINORMAL = oldBinormal;
    reflection_accum = vec4(1.0, 0.0, 0.0, 0.0);
    ambient_accum = vec4(0.0, 0.0, 0.0, 0.0);
	env_reflection_light = vec3(0.0);
	ambient_light = LM_AMBIENTTERM(ambient_term_);
    for (int idx = 0; idx < LM_FWDLIGHT_INT(reflection_count_); idx++) {
		LM_FWDLIGHT_INT(refl_process_);
    }
	if (!LM_CHECKDEFINE(USE_LIGHTMAP) && !LM_CHECKDEFINE(USE_LIGHTMAP_CAPTURE)) {
	    if (ambient_accum.a > 0.0) {
			ambient_light = ambient_accum.rgb / ambient_accum.a;
	    }
	}
	ambient_light += LM_VERTLIGHT(diffuse_light_interp_).rgb;

    vec3 indirectLighting = mix(toonedGI, ambient_light, _IndirectLightIntensity);
    indirectLighting = mix(indirectLighting, max(vec3(EPS_COL), max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z))), _LightColorAttenuation); // color atten
//#endif

    // Albedo color
    vec4 shade = _ShadeColor * texture(_ShadeTexture, mainUv);
    vec4 lit = albedo * mainTex;
	
	vec3 col;
	float lightIntensity;
	vec3 lighting = calculateLighting(mainUv, dotNL, lightAttenuation, shade, lit, lightColor, col, lightIntensity);

    // base light does not darken.
    col *= lighting;

    col += indirectLighting * lit.rgb;
   
    //col = min(col, lit.rgb); // comment out if you want to PBR absolutely.

    // parametric rim lighting
    vec3 staticRimLighting = vec3(1.0);
    vec3 mixedRimLighting = lighting + indirectLighting;

    vec3 rimLighting = mix(staticRimLighting, mixedRimLighting, _RimLightingMix);
    vec3 rim = pow(clamp(1.0 - dot(viewNormal, viewView) + _RimLift, 0.0, 1.0), _RimFresnelPower) * _RimColor.rgb * texture(_RimTexture, mainUv).rgb;
    col += mix(rim * rimLighting, vec3(0, 0, 0), isOutline);


    // additive matcap
    vec3 viewCameraUp = vec3(0.0,1.0,0.0);//normalize(CAMERA_MATRIX[1].xyz); // FIXME!!
    vec3 viewViewUp = normalize(viewCameraUp - viewView * dot(viewView, viewCameraUp));
    vec3 viewViewRight = normalize(cross(viewView, viewViewUp));
    vec2 matcapUv = vec2(-dot(viewViewRight, viewNormal), dot(viewViewUp, viewNormal)) * 0.5 + 0.5;
    vec3 matcapLighting = texture(_SphereAdd, matcapUv).rgb;
    col += mix(matcapLighting, vec3(0, 0, 0), isOutline);

    // Emission
    vec3 emission = texture(_EmissionMap, mainUv).rgb * _EmissionColor.rgb;
    col += mix(emission, vec3(0, 0, 0), isOutline);


	vec3 addLightIntensity = vec3(0.0);
	if (CALCULATE_LIGHTING_IN_FRAGMENT) {

	    for (int idx = 0; idx < LM_FWDLIGHT_INT(omni_light_count_); idx++) {
			vec3 light_rel_vec = LM_FWDLIGHT(omni_light_pos_inv_radius_, idx).xyz - VERTEX;
			float light_length = length(light_rel_vec);
			float normalized_distance = light_length * LM_FWDLIGHT(omni_light_pos_inv_radius_, idx).w;
			float omni_attenuation;
			if (normalized_distance < 1.0) {
				omni_attenuation = pow(1.0 - normalized_distance, LM_FWDLIGHT(omni_light_direction_attenuation_, idx).w);
			} else {
				omni_attenuation = 0.0;
			}
			vec3 light_attenuation = vec3(omni_attenuation);

			float atten = LM_FWDLIGHT(omni_light_direction_attenuation_, idx).w;
			vec4 light_pos_inv_radius = LM_FWDLIGHT(omni_light_pos_inv_radius_, idx);
			vec3 light_color = LM_FWDLIGHT(omni_light_color_energy_, idx).rgb;
			
			float addShadowAttenuation = omni_attenuation * length(LM_SHADOWATTEN(omni_shadow_atten_))/length(vec3(1.0));

			float addDotNL = dot(normalize(light_rel_vec), -viewNormal);

			vec3 addCol = vec3(0.0);
			float addTmp;
			vec3 addLighting = calculateLighting(mainUv, addDotNL, 1.0, shade, lit, light_color, addCol, addTmp);
			addLightIntensity += addLighting * addTmp;
			col += calculateAddLighting(mainUv, addDotNL, dot(viewNormal, viewView), addShadowAttenuation, addLighting, addCol);
	    }


	    for (int idx = 0; idx < LM_FWDLIGHT_INT(spot_light_count_); idx++) {
			vec3 light_rel_vec = LM_FWDLIGHT(spot_light_pos_inv_radius_, idx).xyz - VERTEX;
			float light_length = length(light_rel_vec);
			float normalized_distance = light_length * LM_FWDLIGHT(spot_light_pos_inv_radius_, idx).w;
			float spot_attenuation;
			if (normalized_distance < 1.0) {
				spot_attenuation = pow(1.0 - normalized_distance, LM_FWDLIGHT(spot_light_direction_attenuation_, idx).w);
			} else {
				spot_attenuation = 0.0;
			}
			vec3 spot_dir = LM_FWDLIGHT(spot_light_direction_attenuation_, idx).xyz;
			float spot_cutoff = LM_FWDLIGHT(spot_light_params_, idx).y;
			float scos = max(dot(-normalize(light_rel_vec), spot_dir), spot_cutoff);
			float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - spot_cutoff));
			spot_attenuation *= 1.0 - pow(spot_rim, LM_FWDLIGHT(spot_light_params_, idx).x);
			vec3 light_attenuation = vec3(spot_attenuation);

			float atten = LM_FWDLIGHT(spot_light_direction_attenuation_, idx).w;
			vec4 light_pos_inv_radius = LM_FWDLIGHT(spot_light_pos_inv_radius_, idx);
			vec3 light_color = LM_FWDLIGHT(spot_light_color_energy_, idx).rgb;
			
			float addShadowAttenuation = spot_attenuation * length(LM_SHADOWATTEN(spot_shadow_atten_))/length(vec3(1.0));

			float addDotNL = dot(normalize(light_rel_vec), -viewNormal);

			vec3 addCol = vec3(0.0);
			float addTmp;
			vec3 addLighting = calculateLighting(mainUv, addDotNL, 1.0, shade, lit, light_color, addCol, addTmp);
			addLightIntensity += addLighting * addTmp;
			col += calculateAddLighting(mainUv, addDotNL, dot(viewNormal, viewView), addShadowAttenuation, addLighting, addCol);
	    }

	}



    // outline
	if (isOutline == 1.0) {
		if (MTOON_OUTLINE_COLOR_FIXED) {
	        col = mix(col, _OutlineColor.rgb, isOutline);
		} else if (MTOON_OUTLINE_COLOR_MIXED) {
	        col = mix(col, _OutlineColor.rgb * mix(vec3(1, 1, 1), col, _OutlineLightingMix), isOutline);
	    }
	}

    // debug
	if (_DebugMode == 1.0) { //MTOON_DEBUG_NORMAL
		col = ((mat3(CAMERA_MATRIX) * -viewNormal) * 0.5 + vec3(0.5));
	} else if (_DebugMode == 2.0) { //MTOON_DEBUG_LITSHADERATE
		col = lightIntensity * lighting;
	} else if (_DebugMode == 3.0) { // Add pass lighting
		col = addLightIntensity;
	}
    if (!LM_SCENEDATA_BOOL(lm_macro_system_enabled_)) {
        col.rgb = vec3(0.5 + 0.5 * sin(TIME +UV.x+UV.y),0.0,1.0);
    }

    EMISSION = mix(col.rgb, DEBUG_OVERRIDE.rgb, DEBUG_OVERRIDE.a);

	TRANSMISSION = vec3(0.5) - 0.5 * lightDir.xyz;

    ALBEDO = lit.rgb;//vec3(0.0);
	SPECULAR = 1.0;
	ROUGHNESS = 0.0;
	METALLIC = 0.0;
	ALPHA = alpha;
	// if (alpha < _Cutoff) { discard; }

	//METALLIC = metallic;
	//ROUGHNESS = roughness;
	//SPECULAR = specular;
}

float SchlickFresnel(float u) {
	float m = 1.0 - u;
	float m2 = m * m;
	return m2 * m2 * m; // pow(m,5)
}

void light() {
    // uv
    vec2 mainUv = UV; //TRANSFORM_TEX(i.uv0, _MainTex);
    
    // uv anim
    float uvAnim = texture(_UvAnimMaskTexture, mainUv).r * TIME;
    // translate uv in bottom-left origin coordinates.
    mainUv += vec2(_UvAnimScrollX, -_UvAnimScrollY) * uvAnim;
    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.
    float rotateRad = _UvAnimRotation * PI_2 * uvAnim;
    const vec2 rotatePivot = vec2(0.5, 0.5);
    mainUv = mat2(vec2(cos(rotateRad), sin(rotateRad)), vec2(-sin(rotateRad), cos(rotateRad))) * (mainUv - rotatePivot) + rotatePivot;

	if (length(abs(vec3(0.5) + 0.5 * LIGHT.xyz) - TRANSMISSION.xyz) < 0.0001) {
		// Directional Light (we store direction into TRANSMISSION, and see if it matches).
		// We already calculated this in the base pass.
		DIFFUSE_LIGHT = vec3(0.0);
	} else {
		/*
		// Default Godot BRDF.
		float NdotL = dot(NORMAL, LIGHT);
		float cNdotL = max(NdotL, 0.0); // clamped NdotL
		float NdotV = dot(NORMAL, VIEW);
		float cNdotV = max(NdotV, 0.0);

		vec3 H = normalize(VIEW + LIGHT);
		float cNdotH = max(dot(NORMAL, H), 0.0);
		float cLdotH = max(dot(LIGHT, H), 0.0);
		float diffuse_brdf_NL; // BRDF times N.L for calculating diffuse radiance
		{
			float FD90_minus_1 = 2.0 * cLdotH * cLdotH * ROUGHNESS - 0.5;
			float FdV = 1.0 + FD90_minus_1 * SchlickFresnel(cNdotV);
			float FdL = 1.0 + FD90_minus_1 * SchlickFresnel(cNdotL);
			diffuse_brdf_NL = (1.0 / 3.1415926) * FdV * FdL * cNdotL;
		}
		DIFFUSE_LIGHT += 1.0 * LIGHT_COLOR * ALBEDO * diffuse_brdf_NL * ATTENUATION;
		*/
		if (!CALCULATE_LIGHTING_IN_FRAGMENT) {
			float addDotNL = dot(NORMAL, LIGHT);
		    vec4 mainTex = texture(texture_albedo, mainUv);
		    vec4 shade = _ShadeColor * texture(_ShadeTexture, mainUv);
	    	vec4 lit = albedo * mainTex;

			vec3 addCol = vec3(0.0);
			float addTmp;
			vec3 addLighting = calculateLighting(mainUv, addDotNL, 1.0, shade, lit, LIGHT_COLOR, addCol, addTmp);
			// addLighting *= step(0, addDotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
			DIFFUSE_LIGHT += calculateAddLighting(mainUv, addDotNL, dot(NORMAL, VIEW), length(ATTENUATION)/length(vec3(1.0)), addLighting, addCol);
		}
	}
    SPECULAR_LIGHT = vec3(0.0);
}
"
custom_defines = "
/* These constants must be set by the use when using custom_defines */
/* The following values are safe values within the gl4 spec */
#ifndef MAX_LIGHT_DATA_STRUCTS
#define MAX_LIGHT_DATA_STRUCTS 100 /* 409 on nvidia. 16384/160 */
#define MAX_FORWARD_LIGHTS 8
#define MAX_REFLECTION_DATA_STRUCTS 112 /* 455 on nvidia. max allowed 1024 */
#define MAX_SKELETON_BONES 512 /* safe 340. 1365 on nvidia. max allowed 2048 */
#endif

#ifndef m_LM_SCENEDATA_FLOAT
#define m_LM_SCENEDATA_FLOAT(arg) mx_LM_SCENEDATA_FLOAT(arg ## x)
#define m_LM_SCENEDATA_VEC2(arg) mx_LM_SCENEDATA_VEC2(arg ## x)
#define m_LM_SCENEDATA_VEC3(arg) mx_LM_SCENEDATA_VEC3(arg ## x)
#define m_LM_SCENEDATA_VEC4(arg) mx_LM_SCENEDATA_VEC4(arg ## x)
#define m_LM_SCENEDATA_BOOL(arg) mx_LM_SCENEDATA_BOOL(arg ## x)
#define m_LM_SCENEDATA_MAT4(arg) mx_LM_SCENEDATA_MAT4(arg ## x)
#define m_LM_GL_INT(arg) mx_LM_GL_INT(arg ## x)
 
#define PASTE2( a, b) a##b
#define PASTE( a, b) PASTE2( a, b)

#define m_LM_FWDLIGHT_INT(arg) mx_LM_FWDLIGHT_INT(PASTE(arg, PASTE(y, PASTE(USE_FORWARD, _LIGHTING))))
#define m_LM_FWDLIGHT(arg, idx) mx_LM_FWDLIGHT(PASTE(arg, PASTE(y, PASTE(USE_FORWARD, _LIGHTING))))
#define m_LM_VERTLIGHT(arg) mx_LM_VERTLIGHT(PASTE(arg, PASTE(y, PASTE(USE_VERTEX, _LIGHTING))))
#define m_LM_FWDLIGHT_MAT4(arg, idx) mx_LM_FWDLIGHT_MAT4(PASTE(arg, PASTE(y, PASTE(USE_FORWARD, _LIGHTING))))

#define m_LM_DIRLIGHT_BOOL(arg) mx_LM_DIRLIGHT_BOOL(PASTE(arg, PASTE(d, PASTE(USE_LIGHT_DIR, ECTIONAL))))
#define m_LM_DIRLIGHT(arg) mx_LM_DIRLIGHT(PASTE(arg, PASTE(d, PASTE(USE_LIGHT_DIR, ECTIONAL))))
#define m_LM_DIRLIGHT_MAT4(arg) m_LM_DIRLIGHT_MAT4(PASTE(arg, PASTE(d, PASTE(USE_LIGHT_DIR, ECTIONAL))))

// m_gi_probes(pos, normal, roughness, inout vec3 out_specular, inout vec3 out_ambient)
#define m_LM_GIPROBES(arg) mx_LM_GIPROBES(PASTE(arg, PASTE(gp, PASTE(USE_GI, _PROBES))))

#define m_LM_CHECKDEFINE(arg) mx_LM_CHECKDEFINE(PASTE(arg, PASTE(bool, PASTE(PASTE(USE_LIG,HTMAP),PASTE(USE_LIGHT,MAP_CAPTURE)))))
#define m_LM_AMBIENTTERM(arg) mx_LM_AMBIENTTERM(PASTE(arg, PASTE(at, PASTE(PASTE(USE_RADIANCE,_MAP),PASTE(PASTE(USE_LIG,HTMAP),PASTE(USE_LIGHT,MAP_CAPTURE))))))
#define m_LM_ENVREFLLIGHT(arg) mx_LM_ENVREFLLIGHT(PASTE(arg, PASTE(erl, PASTE(USE_RADIANCE, _MAP))))


#define m_LM_SHADOWATTEN(arg) mx_LM_SHADOWATTEN(PASTE(arg, PASTE(os, PASTE(PASTE(USE_SHA,DOW),PASTE(PASTE(LIGHT_DIRECTI,ONAL_SHADOW), PASTE(USE_CONT,ACT_SHADOWS))))))

#define m_LM_DIRSHADOW(arg) mx_LM_DIRSHADOW(PASTE(arg, PASTE(ds, PASTE(PASTE(LIGHT_DIRECTI,ONAL_SHADOW),PASTE(PASTE(LIGHT_U,SE_PSSM2), PASTE(LIGHT_U,SE_PSSM4))))))

#define m_LM_DIRSHADOWBLEND(arg) mx_LM_DIRSHADOWBLEND(PASTE(arg, PASTE(sbl, PASTE(PASTE(LIGHT_U,SE_PSSM_BLEND),PASTE(PASTE(LIGHT_U,SE_PSSM2), PASTE(LIGHT_U,SE_PSSM4))))))

#define m_gi_probes_compute_gp gi_probes_compute(vertex, normal, roughness, m_env_reflection_light, m_ambient_light), 1
#define m_gi_probes_compute_gpUSE_GI_PROBES 0

vec2 get_norm_uv(vec3 norm) {
	norm.xy /= 1.0 + abs(norm.z);
	norm.xy = norm.xy * vec2(0.5, 0.25) + vec2(0.5, 0.25);
	if (norm.z > 0.0) {
			norm.y = 0.5 - norm.y + 0.5;
	}
	return norm.xy;
}

const vec3 lm_cone_dirs[12] = vec3[12](
                           vec3(0.0, 0.0, 1.0),
                           vec3(0.866025, 0.0, 0.5),
                           vec3(0.267617, 0.823639, 0.5),
                           vec3(-0.700629, 0.509037, 0.5),
                           vec3(-0.700629, -0.509037, 0.5),
                           vec3(0.267617, -0.823639, 0.5),
                           vec3(0.0, 0.0, -1.0),
                           vec3(0.866025, 0.0, -0.5),
                           vec3(0.267617, 0.823639, -0.5),
                           vec3(-0.700629, 0.509037, -0.5),
                           vec3(-0.700629, -0.509037, -0.5),
                           vec3(0.267617, -0.823639, -0.5));

vec3 compute_ambient_lightmap_capture(vec3 local_normal, mediump vec4 lightmap_captures[12], bool lightmap_capture_sky, vec3 ambient_light) {
	vec4 captured = vec4(0.0);
	float sum = 0.0;
	for (int i = 0; i < 12; i++) {
		float amount = max(0.0, dot(local_normal, lm_cone_dirs[i])); //not correct, but creates a nice wrap around effect
		captured += lightmap_captures[i] * amount;
		sum += amount;
	}

	captured /= sum;

	if (lightmap_capture_sky) {
		return mix(ambient_light, captured.rgb, captured.a);
	} else {
		return captured.rgb;
	}
}

#define m_env_reflection_light_erlUSE_RADIANCE_MAP (bg_color.rgb * bg_energy)
#define m_env_reflection_light_erl (textureDualParaboloid(radiance_map, normalize((radiance_inverse_xform * vec4(reflect(-eye_vec, normal), 0.0)).xyz), roughness) * bg_energy)

#define do_ambient_term_capture(ambient_light) (compute_ambient_lightmap_capture(normalize(camera_matrix * vec4(normal, 0.0)).xyz, lightmap_captures, lightmap_capture_sky, ambient_light))

#define m_ambient_term_atUSE_LIGHTMAP_CAPTURE texture(lightmap, uv2).rgb * lightmap_energy
#define m_ambient_term_atUSE_RADIANCE_MAPUSE_LIGHTMAP_CAPTURE m_ambient_term_atUSE_LIGHTMAP_CAPTURE

#define m_ambient_term_at do_ambient_term_capture(m_ambient_term_atUSE_LIGHTMAP_CAPTURE)
#define m_ambient_term_atUSE_RADIANCE_MAP m_ambient_term_at

#define m_ambient_term_atUSE_RADIANCE_MAPUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE ambient_light_color.rgb

#define F_Term   (F0(metallic, specular, albedo) + (max(vec3(1.0 - roughness), F0(metallic, specular, albedo)) - F0(metallic, specular, albedo)) * pow(1.0 - clamp(dot(normal, view), 0.0, 1.0), 5.0))

#define m_ambient_term_atUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE mix(ambient_light_color.rgb, texture(irradiance_map, get_norm_uv(normalize((radiance_inverse_xform * vec4(normal, 0.0)).xyz))).rgb * bg_energy * (1.0 - F_Term), radiance_ambient_contribution)

#define m_ambient_term_atUSE_RADIANCE_MAPUSE_LIGHTMAP do_ambient_term_capture(ambient_light_color.rgb)
#define m_ambient_term_atUSE_LIGHTMAP do_ambient_term_capture(m_ambient_term_atUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE)

#define m_USE_LIGHTMAPboolUSE_LIGHTMAP false
#define m_USE_LIGHTMAPboolUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE false
#define m_USE_LIGHTMAPboolUSE_LIGHTMAP_CAPTURE true
#define m_USE_LIGHTMAPbool true

#define m_USE_LIGHTMAP_CAPTUREboolUSE_LIGHTMAP true
#define m_USE_LIGHTMAP_CAPTUREboolUSE_LIGHTMAPUSE_LIGHTMAP_CAPTURE false
#define m_USE_LIGHTMAP_CAPTUREboolUSE_LIGHTMAP_CAPTURE false
#define m_USE_LIGHTMAP_CAPTUREbool true


#define m_lm_macro_system_enabled_x true

// LM_GL_INT
#define m_gl_vertexid_x gl_VertexID
#define m_gl_primitiveid_x gl_PrimitiveID
#define m_gl_instanceid_x gl_InstanceID

// LM_SCENEDATA_...
#define m_world_transform_x world_transform
#define m_color_interp_x color_interp
#define m_uv_interp_x uv_interp
#define m_uv2_interp_x uv2_interp
#define m_tangent_interp_x tangent_interp
#define m_binormal_interp_x binormal_interp
#define m_vertex_interp_x vertex_interp
#define m_normal_interp_x normal_interp
#define m_radiance_inverse_xform_x radiance_inverse_xform
#define m_radiance_ambient_contribution_x radiance_ambient_contribution

#define m_projection_matrix_x projection_matrix
#define m_inv_projection_matrix_x inv_projection_matrix
#define m_camera_inverse_matrix_x camera_inverse_matrix
#define m_camera_matrix_x camera_matrix
#define m_ambient_light_color_x ambient_light_color
#define m_bg_color_x bg_color
#define m_fog_color_enabled_x fog_color_enabled
#define m_fog_sun_color_amount_x fog_sun_color_amount
#define m_ambient_energy_x ambient_energy
#define m_bg_energy_x bg_energy
#define m_z_offset_x z_offset
#define m_z_slope_scale_x z_slope_scale
#define m_shadow_dual_paraboloid_render_zfar_x shadow_dual_paraboloid_render_zfar
#define m_shadow_dual_paraboloid_render_side_x shadow_dual_paraboloid_render_side
#define m_viewport_size_x viewport_size
#define m_screen_pixel_size_x screen_pixel_size
#define m_shadow_atlas_pixel_size_x shadow_atlas_pixel_size
#define m_directional_shadow_pixel_size_x directional_shadow_pixel_size
#define m_time_x time
#define m_z_far_x z_far
#define m_reflection_multiplier_x reflection_multiplier
#define m_subsurface_scatter_width_x subsurface_scatter_width
#define m_ambient_occlusion_affect_light_x ambient_occlusion_affect_light
#define m_ambient_occlusion_affect_ao_channel_x ambient_occlusion_affect_ao_channel
#define m_opaque_prepass_threshold_x opaque_prepass_threshold
#define m_fog_depth_enabled_x fog_depth_enabled
#define m_fog_depth_begin_x fog_depth_begin
#define m_fog_depth_end_x fog_depth_end
#define m_fog_density_x fog_density
#define m_fog_depth_curve_x fog_depth_curve
#define m_fog_transmit_enabled_x fog_transmit_enabled
#define m_fog_transmit_curve_x fog_transmit_curve
#define m_fog_height_enabled_x fog_height_enabled
#define m_fog_height_min_x fog_height_min
#define m_fog_height_max_x fog_height_max
#define m_fog_height_curve_x fog_height_curve

// LM_DIRLIGHT...
#define m_dir_light_pos_inv_radius_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
#define m_dir_light_direction_attenuation_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
#define m_dir_light_color_energy_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
#define m_dir_light_params_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
#define m_dir_light_clamp_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
// LM_DIRSHADOW...
#define m_dir_shadow_color_contact_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
#define m_dir_shadow_matrix1_dUSE_LIGHT_DIRECTIONAL mat4(0.0)
#define m_dir_shadow_matrix2_dUSE_LIGHT_DIRECTIONAL mat4(0.0)
#define m_dir_shadow_matrix3_dUSE_LIGHT_DIRECTIONAL mat4(0.0)
#define m_dir_shadow_matrix4_dUSE_LIGHT_DIRECTIONAL mat4(0.0)
#define m_dir_shadow_split_offsets_dUSE_LIGHT_DIRECTIONAL vec4(0.0)
#define m_has_dir_light_dUSE_LIGHT_DIRECTIONAL false

#define m_dir_light_pos_inv_radius_d light_pos_inv_radius
#define m_dir_light_direction_attenuation_d light_direction_attenuation
#define m_dir_light_color_energy_d light_color_energy
#define m_dir_light_params_d light_params
#define m_dir_light_clamp_d light_clamp
#define m_dir_shadow_color_contact_d shadow_color_contact
#define m_dir_shadow_matrix1_d shadow_matrix1
#define m_dir_shadow_matrix2_d shadow_matrix2
#define m_dir_shadow_matrix3_d shadow_matrix3
#define m_dir_shadow_matrix4_d shadow_matrix4
#define m_dir_shadow_split_offsets_d shadow_split_offsets
#define m_has_dir_light_d true

// LM_VERTLIGHT
#define m_diffuse_light_interp_yUSE_VERTEX_LIGHTING vec4(0.0)
#define m_specular_light_interp_yUSE_VERTEX_LIGHTING vec4(0.0)
#define m_diffuse_light_interp_y diffuse_light_interp
#define m_specular_light_interp_y specular_light_interp

// LM_FWDLIGHT
#define m_omni_light_pos_inv_radius_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_omni_light_direction_attenuation_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_omni_light_color_energy_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_omni_light_params_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_omni_light_clamp_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_omni_shadow_color_contact_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_omni_shadow_matrix_yUSE_FORWARD_LIGHTING mat4(0.0)
#define m_omni_light_pos_inv_radius_y omni_lights[omni_light_indices[m_idx]].light_pos_inv_radius
#define m_omni_light_direction_attenuation_y omni_lights[omni_light_indices[m_idx]].light_direction_attenuation
#define m_omni_light_color_energy_y omni_lights[omni_light_indices[m_idx]].light_color_energy
#define m_omni_light_params_y omni_lights[omni_light_indices[m_idx]].light_params
#define m_omni_light_clamp_y omni_lights[omni_light_indices[m_idx]].light_clamp
#define m_omni_shadow_color_contact_y omni_lights[omni_light_indices[m_idx]].shadow_color_contact
#define m_omni_shadow_matrix_y omni_lights[omni_light_indices[m_idx]].shadow_matrix

#define m_spot_light_pos_inv_radius_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_spot_light_direction_attenuation_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_spot_light_color_energy_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_spot_light_params_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_spot_light_clamp_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_spot_shadow_color_contact_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_spot_shadow_matrix_yUSE_FORWARD_LIGHTING mat4(0.0)
#define m_spot_light_pos_inv_radius_y spot_lights[spot_light_indices[m_idx]].light_pos_inv_radius
#define m_spot_light_direction_attenuation_y spot_lights[spot_light_indices[m_idx]].light_direction_attenuation
#define m_spot_light_color_energy_y spot_lights[spot_light_indices[m_idx]].light_color_energy
#define m_spot_light_params_y spot_lights[spot_light_indices[m_idx]].light_params
#define m_spot_light_clamp_y spot_lights[spot_light_indices[m_idx]].light_clamp
#define m_spot_shadow_color_contact_y spot_lights[spot_light_indices[m_idx]].shadow_color_contact
#define m_spot_shadow_matrix_y spot_lights[spot_light_indices[m_idx]].shadow_matrix

#define m_refl_box_extents_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_refl_box_offset_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_refl_params_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_refl_ambient_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_refl_atlas_clamp_yUSE_FORWARD_LIGHTING vec4(0.0)
#define m_refl_local_matrix_yUSE_FORWARD_LIGHTING mat4(0.0)
#define m_refl_process_yUSE_FORWARD_LIGHTING 0
#define m_refl_box_extents_y reflections[reflection_indices[m_idx]].box_extents
#define m_refl_box_offset_y reflections[reflection_indices[m_idx]].box_offset
#define m_refl_params_y reflections[reflection_indices[m_idx]].params
#define m_refl_ambient_y reflections[reflection_indices[m_idx]].ambient
#define m_refl_atlas_clamp_y reflections[reflection_indices[m_idx]].atlas_clamp
#define m_refl_local_matrix_y reflections[reflection_indices[m_idx]].local_matrix
#define m_refl_process_y (reflection_process(reflection_indices[m_idx], vertex, normal, binormal, tangent, roughness, anisotropy, m_ambient_light, m_env_reflection_light,m_reflection_accum, m_ambient_accum),1)
#define m_omni_light_count_yUSE_FORWARD_LIGHTING 0
#define m_spot_light_count_yUSE_FORWARD_LIGHTING 0
#define m_reflection_count_yUSE_FORWARD_LIGHTING 0
#define m_omni_light_count_y omni_light_count
#define m_spot_light_count_y spot_light_count
#define m_reflection_count_y reflection_count

#define m_diffuse_buffer_x diffuse_buffer
#define m_specular_buffer_x specular_buffer
#define m_normal_mr_buffer_x normal_mr_buffer
#define m_sss_buffer_x sss_buffer
#define m_frag_color_x frag_color
#define m_position_interp_x position_interp

// Note: We cannot use these defines for now, as they bleed into other shaders.
//#define SHADOWS_DISABLED
//#define SHADELESS


float combine_contact_shadow(float shadow, float contact_shadow, float color_contact_a) {
    if (shadow > 0.01 && color_contact_a > 0.0) {
        shadow = min(shadow, contact_shadow);
    }
    return shadow;
}

vec3 get_omni_splane(mat4 shadow_matrix, vec3 vertex, vec4 light_clamp, float inv_radius_w) {
    highp vec3 splane = (shadow_matrix * vec4(vertex, 1.0)).xyz;
    float shadow_len = length(splane);
    splane = normalize(splane);
    vec4 clamp_rect = light_clamp;

    if (splane.z >= 0.0) {

        splane.z += 1.0;

        clamp_rect.y += clamp_rect.w;

    } else {

        splane.z = 1.0 - splane.z;

        /*
        if (clamp_rect.z < clamp_rect.w) {
            clamp_rect.x += clamp_rect.z;
        } else {
            clamp_rect.y += clamp_rect.w;
        }
        */
    }

    splane.xy /= splane.z;
    splane.xy = splane.xy * 0.5 + 0.5;
    splane.z = shadow_len * inv_radius_w;

    splane.xy = clamp_rect.xy + splane.xy * clamp_rect.zw;
    return splane.xyz;
}

vec3 get_splane(mat4 shadow_matrix, vec3 vertex) {
    vec4 splane = shadow_matrix * vec4(vertex, 1.0);
    vec3 pssm_coord = splane.xyz / splane.w;
    return pssm_coord;
}


#define m_omni_shadow_contact(splane, color_contact) mix(omni_lights[m_idx].shadow_color_contact.rgb, vec3(1.0), combine_contact_shadow (sample_shadow(shadow_atlas, shadow_atlas_pixel_size, splane.xy, splane.z, vec4(0.0)), contact_shadow_compute(vertex, normalize(light_rel_vec), min(light_length, omni_lights[m_idx].shadow_color_contact.a)), color_contact)))

#define m_omni_shadow_nocontact(splane) mix(omni_lights[m_idx].shadow_color_contact.rgb, vec3(1.0), sample_shadow(shadow_atlas, shadow_atlas_pixel_size, splane.xy, splane.z, vec4(0.0)))

#define m_omni_shadow_atten_os (omni_lights[m_idx].light_params.w > 0.5) ? m_omni_shadow_contact(get_omni_splane(omni_lights[m_idx].shadow_matrix, vertex, omni_lights[m_idx].light_clamp, i_lights[m_idx].light_pos_inv_radius.w), omni_lights[m_idx].shadow_color_contact.a) : vec3(1.0)
#define m_omni_shadow_atten_osUSE_CONTACT_SHADOWS (omni_lights[m_idx].light_params.w > 0.5) ? m_omni_shadow_nocontact(get_omni_splane(omni_lights[m_idx].shadow_matrix, vertex, omni_lights[m_idx].light_clamp, omni_lights[m_idx].light_pos_inv_radius.w)) : vec3(1.0)
#define m_omni_shadow_atten_osUSE_SHADOW vec3(1.0)
#define m_omni_shadow_atten_osUSE_SHADOWUSE_CONTACT_SHADOWS vec3(1.0)
#define m_omni_shadow_atten_osLIGHT_DIRECTIONAL_SHADOW m_omni_shadow_atten_os
#define m_omni_shadow_atten_osLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS m_omni_shadow_atten_osUSE_CONTACT_SHADOWS
#define m_omni_shadow_atten_osUSE_SHADOWLIGHT_DIRECTIONAL_SHADOW vec3(1.0)
#define m_omni_shadow_atten_osUSE_SHADOWLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS vec3(1.0)

#define m_spot_shadow_contact(splane, color_contact) mix(spot_lights[m_idx].shadow_color_contact.rgb, vec3(1.0), combine_contact_shadow (sample_shadow(shadow_atlas, shadow_atlas_pixel_size, splane.xy, splane.z, vec4(0.0)), contact_shadow_compute(vertex, normalize(light_rel_vec), color_contact)))

#define m_spot_shadow_nocontact(splane) mix(spot_lights[m_idx].shadow_color_contact.rgb, vec3(1.0), sample_shadow(shadow_atlas, shadow_atlas_pixel_size, splane.xy, splane.z, vec4(0.0)))

#define m_spot_shadow_atten_os (spot_lights[m_idx].light_params.w > 0.5) ? m_spot_shadow_contact(get_splane(spot_lights[m_idx].shadow_matrix, vertex), min(light_length, spot_lights[m_idx].shadow_color_contact.a)) : vec3(1.0)
#define m_spot_shadow_atten_osUSE_CONTACT_SHADOWS (spot_lights[m_idx].light_params.w > 0.5) ? m_spot_shadow_nocontact(get_splane(spot_lights[m_idx].shadow_matrix, vertex)) : vec3(1.0)
#define m_spot_shadow_atten_osUSE_SHADOW vec3(1.0)
#define m_spot_shadow_atten_osUSE_SHADOWUSE_CONTACT_SHADOWS vec3(1.0)
#define m_spot_shadow_atten_osLIGHT_DIRECTIONAL_SHADOW m_spot_shadow_atten_os
#define m_spot_shadow_atten_osLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS m_spot_shadow_atten_osUSE_CONTACT_SHADOWS
#define m_spot_shadow_atten_osUSE_SHADOWLIGHT_DIRECTIONAL_SHADOW vec3(1.0)
#define m_spot_shadow_atten_osUSE_SHADOWLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS vec3(1.0)


#define do_sample_shadow(splane) sample_shadow(directional_shadow, directional_shadow_pixel_size, splane.xy, splane.z, vec4(0.0))

#define tmp_shadow_matrix1 (m_dir_shadow_which_matrix == 1.0 ? shadow_matrix1 : (m_dir_shadow_which_matrix == 2.0 ? shadow_matrix2 : (m_dir_shadow_which_matrix == 3.0 ? shadow_matrix3 : shadow_matrix4)))
#define tmp_shadow_matrix2 (m_dir_shadow_which_matrix == 1.0 ? shadow_matrix2 : (m_dir_shadow_which_matrix == 2.0 ? shadow_matrix3 : shadow_matrix4))
#define m_dir_inner_shadow mix(do_sample_shadow(get_splane(tmp_shadow_matrix1,vertex)), do_sample_shadow(get_splane(tmp_shadow_matrix2,vertex)), m_dir_shadow_blend)
#define m_dir_shadow_contact(color_contact) mix(mix(shadow_color_contact.rgb, vec3(1.0), combine_contact_shadow(m_dir_inner_shadow, contact_shadow_compute(vertex, -light_direction_attenuation.xyz, shadow_color_contact.a), color_contact)), vec3(1.0), m_dir_shadow_fade)
#define m_dir_shadow_nocontact mix(mix(shadow_color_contact.rgb, vec3(1.0), m_dir_inner_shadow), vec3(1.0), m_dir_shadow_fade)

#define light_depth_z (-vertex.z)
#define m_dir_shadow_atten_os (light_depth_z < m_dir_shadow_offset) ? m_dir_shadow_contact(shadow_color_contact.a) : vec3(1.0)
#define m_dir_shadow_atten_osUSE_CONTACT_SHADOWS (light_depth_z < m_dir_shadow_offset) ? m_dir_shadow_nocontact : vec3(1.0)
#define m_dir_shadow_atten_osLIGHT_DIRECTIONAL_SHADOW vec3(1.0)
#define m_dir_shadow_atten_osLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS vec3(1.0)
#define m_dir_shadow_atten_osUSE_SHADOW m_dir_shadow_atten_os
#define m_dir_shadow_atten_osUSE_SHADOWUSE_CONTACT_SHADOWS m_dir_shadow_atten_osUSE_CONTACT_SHADOWS
#define m_dir_shadow_atten_osUSE_SHADOWLIGHT_DIRECTIONAL_SHADOW vec3(1.0)
#define m_dir_shadow_atten_osUSE_SHADOWLIGHT_DIRECTIONAL_SHADOWUSE_CONTACT_SHADOWS vec3(1.0)



#define m_dir_shadow_offset_dsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2LIGHT_USE_PSSM4 -1.0e10
#define m_dir_shadow_offset_dsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2 -1.0e10
#define m_dir_shadow_offset_dsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM4 -1.0e10
#define m_dir_shadow_offset_dsLIGHT_DIRECTIONAL_SHADOW -1.0e10
#define m_dir_shadow_offset_dsLIGHT_USE_PSSM2LIGHT_USE_PSSM4 shadow_split_offsets.x
#define m_dir_shadow_offset_dsLIGHT_USE_PSSM2 shadow_split_offsets.w
#define m_dir_shadow_offset_dsLIGHT_USE_PSSM4 shadow_split_offsets.y
#define m_dir_shadow_offset_ds shadow_split_offsets.w


#define m_dir_shadow_blend_sblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2LIGHT_USE_PSSM4 0.0
#define m_dir_shadow_blend_sblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM4 0.0
#define m_dir_shadow_blend_sblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2 0.0
#define m_dir_shadow_blend_sblLIGHT_USE_PSSM_BLEND 0.0
#define m_dir_shadow_blend_sblLIGHT_USE_PSSM2LIGHT_USE_PSSM4 0.0
#define m_dir_shadow_blend_sblLIGHT_USE_PSSM2 (light_depth_z < shadow_split_offsets.y ? ((light_depth_z < shadow_split_offsets.x) ? smoothstep(0.0, shadow_split_offsets.x, light_depth_z) : smoothstep(shadow_split_offsets.x, shadow_split_offsets.y, light_depth_z)) : ((light_depth_z < shadow_split_offsets.z) ? smoothstep(shadow_split_offsets.y, shadow_split_offsets.z, light_depth_z) : 0.0)
#define m_dir_shadow_blend_sblLIGHT_USE_PSSM4 (light_depth_z < shadow_split_offsets.x) ? smoothstep(0.0, shadow_split_offsets.x, light_depth_z) : 0.0
#define m_dir_shadow_blend_sbl m_dir_shadow_blend_sblLIGHT_USE_PSSM4

#define m_dir_shadow_fade_sblLIGHT_USE_PSSM2LIGHT_USE_PSSM4 0.0
#define m_dir_shadow_fade_sblLIGHT_USE_PSSM2 ((light_depth_z < shadow_split_offsets.y) || (light_depth_z < shadow_split_offsets.z)) ? 0.0 : smoothstep(shadow_split_offsets.z, shadow_split_offsets.w, light_depth_z)
#define m_dir_shadow_fade_sblLIGHT_USE_PSSM4 (light_depth_z < shadow_split_offsets.x) ? 0.0 : smoothstep(shadow_split_offsets.x, shadow_split_offsets.y, light_depth_z)
#define m_dir_shadow_fade_sbl m_dir_shadow_fade_sblLIGHT_USE_PSSM4
#define m_dir_shadow_fade_sblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2LIGHT_USE_PSSM4 0.0
#define m_dir_shadow_fade_sblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM4 m_dir_shadow_fade_sblLIGHT_USE_PSSM4
#define m_dir_shadow_fade_sblLIGHT_USE_PSSM_BLENDLIGHT_USE_PSSM2 m_dir_shadow_fade_sblLIGHT_USE_PSSM2
#define m_dir_shadow_fade_sblLIGHT_USE_PSSM_BLEND 0.0

#define m_dir_shadow_which_matrix_dsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2LIGHT_USE_PSSM4 1.0
#define m_dir_shadow_which_matrix_dsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM4 1.0
#define m_dir_shadow_which_matrix_dsLIGHT_DIRECTIONAL_SHADOWLIGHT_USE_PSSM2 1.0
#define m_dir_shadow_which_matrix_dsLIGHT_DIRECTIONAL_SHADOW 1.0
#define m_dir_shadow_which_matrix_dsLIGHT_USE_PSSM2LIGHT_USE_PSSM4 1.0
#define m_dir_shadow_which_matrix_dsLIGHT_USE_PSSM2 (light_depth_z < shadow_split_offsets.y ? ((light_depth_z < shadow_split_offsets.x) ? 1.0 : 2.0) : ((light_depth_z < shadow_split_offsets.z) ? 3.0 : 4.0))
#define m_dir_shadow_which_matrix_dsLIGHT_USE_PSSM4 ((light_depth_z < shadow_split_offsets.x) ? 1.0 : 2.0)
#define m_dir_shadow_which_matrix_ds m_dir_shadow_which_matrix_dsLIGHT_USE_PSSM4
#endif

"
